/* This file is generated. Do not edit manually. */
use crate::biome::Biome;
use crate::dimension::Dimension;
use pumpkin_util::random::RandomDeriver;
use pumpkin_util::y_offset::Absolute;
use pumpkin_util::y_offset::YOffset;
use std::{cell::RefCell, num::NonZeroUsize};
pub struct BlockBlueprint {
    pub name: &'static str,
    pub properties: Option<&'static [(&'static str, &'static str)]>,
}
pub struct GenerationSettings {
    pub aquifers_enabled: bool,
    pub ore_veins_enabled: bool,
    pub legacy_random_source: bool,
    pub sea_level: i32,
    pub default_fluid: BlockBlueprint,
    pub shape: GenerationShapeConfig,
    pub surface_rule: MaterialRule,
    pub default_block: BlockBlueprint,
}
pub struct GenerationShapeConfig {
    pub min_y: i8,
    pub height: u16,
    pub size_horizontal: u8,
    pub size_vertical: u8,
}
impl GenerationShapeConfig {
    #[inline]
    #[must_use]
    pub fn vertical_cell_block_count(&self) -> u8 {
        self.size_vertical << 2
    }
    #[inline]
    #[must_use]
    pub fn horizontal_cell_block_count(&self) -> u8 {
        self.size_horizontal << 2
    }
    #[must_use]
    pub const fn max_y(&self) -> u16 {
        if self.min_y >= 0 {
            self.height + self.min_y as u16
        } else {
            (self.height as i32 + self.min_y as i32) as u16
        }
    }
    pub fn trim_height(&self, bottom_y: i8, top_y: u16) -> Self {
        let new_min = self.min_y.max(bottom_y);
        let this_top = if self.min_y >= 0 {
            self.height + self.min_y as u16
        } else {
            self.height - self.min_y.unsigned_abs() as u16
        };
        let new_top = this_top.min(top_y);
        let new_height = if new_min >= 0 {
            new_top - new_min as u16
        } else {
            new_top + new_min.unsigned_abs() as u16
        };
        Self {
            min_y: new_min,
            height: new_height,
            size_horizontal: self.size_horizontal,
            size_vertical: self.size_vertical,
        }
    }
}
pub struct BlockMaterialRule {
    pub result_state: BlockBlueprint,
}
pub struct SequenceMaterialRule {
    pub sequence: &'static [MaterialRule],
}
pub struct ConditionMaterialRule {
    pub if_true: MaterialCondition,
    pub then_run: &'static MaterialRule,
}
pub struct BadLandsMaterialRule;
pub enum MaterialRule {
    Block(BlockMaterialRule),
    Sequence(SequenceMaterialRule),
    Condition(ConditionMaterialRule),
    Badlands(BadLandsMaterialRule),
    Unsupported,
}
pub struct BiomeMaterialCondition {
    pub biome_is: &'static [&'static Biome],
}
pub struct NoiseThresholdMaterialCondition {
    pub noise: &'static str,
    pub min_threshold: f64,
    pub max_threshold: f64,
}
pub struct VerticalGradientMaterialCondition {
    pub random_name: &'static str,
    pub true_at_and_below: YOffset,
    pub false_at_and_above: YOffset,
}
pub struct AboveYMaterialCondition {
    pub anchor: YOffset,
    pub surface_depth_multiplier: i32,
    pub add_stone_depth: bool,
}
pub struct WaterMaterialCondition {
    pub offset: i32,
    pub surface_depth_multiplier: i32,
    pub add_stone_depth: bool,
}
pub struct HoleMaterialCondition;
pub struct NotMaterialCondition {
    pub invert: &'static MaterialCondition,
}
pub struct SurfaceMaterialCondition;
pub struct StoneDepthMaterialCondition {
    pub offset: i32,
    pub add_surface_depth: bool,
    pub secondary_depth_range: i32,
    pub surface_type: pumpkin_util::math::vertical_surface_type::VerticalSurfaceType,
}
pub enum MaterialCondition {
    Biome(BiomeMaterialCondition),
    NoiseThreshold(NoiseThresholdMaterialCondition),
    VerticalGradient(VerticalGradientMaterialCondition),
    YAbove(AboveYMaterialCondition),
    Water(WaterMaterialCondition),
    Temperature,
    Steep,
    Not(NotMaterialCondition),
    Hole(HoleMaterialCondition),
    AbovePreliminarySurface(SurfaceMaterialCondition),
    StoneDepth(StoneDepthMaterialCondition),
}
impl GenerationSettings {
    pub const AMPLIFIED : GenerationSettings = GenerationSettings { aquifers_enabled : true , ore_veins_enabled : true , legacy_random_source : false , sea_level : 63i32 , default_fluid : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : - 64i8 , height : 384u16 , size_horizontal : 1u8 , size_vertical : 2u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_floor" , true_at_and_below : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 0i8 }) , false_at_and_above : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 5i8 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: AbovePreliminarySurface (SurfaceMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 97i16 }) , surface_depth_multiplier : 2i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 62i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 60i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BADLANDS , & crate :: biome :: Biome :: ERODED_BADLANDS , & crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 256i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "air" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Temperature , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } })] }) }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : 0f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : 0f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.06060606060606061f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: OLD_GROWTH_PINE_TAIGA , & crate :: biome :: Biome :: OLD_GROWTH_SPRUCE_TAIGA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.11515151515151514f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "podzol" , properties : Some (& [("snowy" , "false")]) , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: ICE_SPIKES] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MUSHROOM_FIELDS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mycelium" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : - 0.5f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : - 0.0625f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 6i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 30i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS , & crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: LUKEWARM_OCEAN , & crate :: biome :: Biome :: DEEP_LUKEWARM_OCEAN] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:deepslate" , true_at_and_below : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 0i16 }) , false_at_and_above : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 8i16 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "deepslate" , properties : Some (& [("axis" , "y")]) , } }) })] }) , default_block : BlockBlueprint { name : "stone" , properties : None , } , } ;
    pub const CAVES : GenerationSettings = GenerationSettings { aquifers_enabled : false , ore_veins_enabled : false , legacy_random_source : true , sea_level : 32i32 , default_fluid : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : - 64i8 , height : 192u16 , size_horizontal : 1u8 , size_vertical : 2u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_roof" , true_at_and_below : YOffset :: BelowTop (pumpkin_util :: y_offset :: BelowTop { below_top : 5i8 }) , false_at_and_above : YOffset :: BelowTop (pumpkin_util :: y_offset :: BelowTop { below_top : 0i8 }) , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_floor" , true_at_and_below : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 0i8 }) , false_at_and_above : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 5i8 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 97i16 }) , surface_depth_multiplier : 2i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 62i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 60i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BADLANDS , & crate :: biome :: Biome :: ERODED_BADLANDS , & crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 256i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "air" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Temperature , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } })] }) }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : 0f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : 0f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.06060606060606061f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: OLD_GROWTH_PINE_TAIGA , & crate :: biome :: Biome :: OLD_GROWTH_SPRUCE_TAIGA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.11515151515151514f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "podzol" , properties : Some (& [("snowy" , "false")]) , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: ICE_SPIKES] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MUSHROOM_FIELDS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mycelium" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : - 0.5f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : - 0.0625f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 6i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 30i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS , & crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: LUKEWARM_OCEAN , & crate :: biome :: Biome :: DEEP_LUKEWARM_OCEAN] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:deepslate" , true_at_and_below : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 0i16 }) , false_at_and_above : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 8i16 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "deepslate" , properties : Some (& [("axis" , "y")]) , } }) })] }) , default_block : BlockBlueprint { name : "stone" , properties : None , } , } ;
    pub const END: GenerationSettings = GenerationSettings {
        aquifers_enabled: false,
        ore_veins_enabled: false,
        legacy_random_source: true,
        sea_level: 0i32,
        default_fluid: BlockBlueprint {
            name: "air",
            properties: None,
        },
        shape: GenerationShapeConfig {
            min_y: 0i8,
            height: 128u16,
            size_horizontal: 2u8,
            size_vertical: 1u8,
        },
        surface_rule: MaterialRule::Block(BlockMaterialRule {
            result_state: BlockBlueprint {
                name: "end_stone",
                properties: None,
            },
        }),
        default_block: BlockBlueprint {
            name: "end_stone",
            properties: None,
        },
    };
    pub const FLOATING_ISLANDS : GenerationSettings = GenerationSettings { aquifers_enabled : false , ore_veins_enabled : false , legacy_random_source : true , sea_level : - 64i32 , default_fluid : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : 0i8 , height : 256u16 , size_horizontal : 2u8 , size_vertical : 1u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 97i16 }) , surface_depth_multiplier : 2i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 62i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 60i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BADLANDS , & crate :: biome :: Biome :: ERODED_BADLANDS , & crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 256i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "air" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Temperature , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } })] }) }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : 0f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : 0f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.06060606060606061f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: OLD_GROWTH_PINE_TAIGA , & crate :: biome :: Biome :: OLD_GROWTH_SPRUCE_TAIGA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.11515151515151514f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "podzol" , properties : Some (& [("snowy" , "false")]) , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: ICE_SPIKES] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MUSHROOM_FIELDS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mycelium" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : - 0.5f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : - 0.0625f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 6i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 30i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS , & crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: LUKEWARM_OCEAN , & crate :: biome :: Biome :: DEEP_LUKEWARM_OCEAN] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:deepslate" , true_at_and_below : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 0i16 }) , false_at_and_above : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 8i16 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "deepslate" , properties : Some (& [("axis" , "y")]) , } }) })] }) , default_block : BlockBlueprint { name : "stone" , properties : None , } , } ;
    pub const LARGE_BIOMES : GenerationSettings = GenerationSettings { aquifers_enabled : true , ore_veins_enabled : true , legacy_random_source : false , sea_level : 63i32 , default_fluid : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : - 64i8 , height : 384u16 , size_horizontal : 1u8 , size_vertical : 2u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_floor" , true_at_and_below : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 0i8 }) , false_at_and_above : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 5i8 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: AbovePreliminarySurface (SurfaceMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 97i16 }) , surface_depth_multiplier : 2i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 62i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 60i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BADLANDS , & crate :: biome :: Biome :: ERODED_BADLANDS , & crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 256i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "air" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Temperature , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } })] }) }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : 0f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : 0f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.06060606060606061f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: OLD_GROWTH_PINE_TAIGA , & crate :: biome :: Biome :: OLD_GROWTH_SPRUCE_TAIGA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.11515151515151514f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "podzol" , properties : Some (& [("snowy" , "false")]) , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: ICE_SPIKES] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MUSHROOM_FIELDS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mycelium" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : - 0.5f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : - 0.0625f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 6i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 30i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS , & crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: LUKEWARM_OCEAN , & crate :: biome :: Biome :: DEEP_LUKEWARM_OCEAN] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:deepslate" , true_at_and_below : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 0i16 }) , false_at_and_above : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 8i16 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "deepslate" , properties : Some (& [("axis" , "y")]) , } }) })] }) , default_block : BlockBlueprint { name : "stone" , properties : None , } , } ;
    pub const NETHER : GenerationSettings = GenerationSettings { aquifers_enabled : false , ore_veins_enabled : false , legacy_random_source : true , sea_level : 32i32 , default_fluid : BlockBlueprint { name : "lava" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : 0i8 , height : 128u16 , size_horizontal : 1u8 , size_vertical : 2u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_floor" , true_at_and_below : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 0i8 }) , false_at_and_above : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 5i8 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_roof" , true_at_and_below : YOffset :: BelowTop (pumpkin_util :: y_offset :: BelowTop { below_top : 5i8 }) , false_at_and_above : YOffset :: BelowTop (pumpkin_util :: y_offset :: BelowTop { below_top : 0i8 }) , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: BelowTop (pumpkin_util :: y_offset :: BelowTop { below_top : 5i8 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "netherrack" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BASALT_DELTAS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "basalt" , properties : Some (& [("axis" , "y")]) , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:patch" , min_threshold : - 0.012f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 30i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 35i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:nether_state_selector" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "basalt" , properties : Some (& [("axis" , "y")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "blackstone" , properties : None , } })] }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SOUL_SAND_VALLEY] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:nether_state_selector" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "soul_sand" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "soul_soil" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:patch" , min_threshold : - 0.012f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 30i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 35i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:nether_state_selector" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "soul_sand" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "soul_soil" , properties : None , } })] }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 32i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "lava" , properties : Some (& [("level" , "0")]) , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARPED_FOREST] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:netherrack" , min_threshold : 0.54f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 31i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:nether_wart" , min_threshold : 1.17f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "warped_wart_block" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "warped_nylium" , properties : None , } })] }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: CRIMSON_FOREST] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:netherrack" , min_threshold : 0.54f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 31i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:nether_wart" , min_threshold : 1.17f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "nether_wart_block" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "crimson_nylium" , properties : None , } })] }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: NETHER_WASTES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:soul_sand_layer" , min_threshold : - 0.012f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 30i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 35i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "soul_sand" , properties : None , } }) }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "netherrack" , properties : None , } })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 31i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 35i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel_layer" , min_threshold : - 0.012f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 32i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } }) })] }) }) }) }) })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "netherrack" , properties : None , } })] }) , default_block : BlockBlueprint { name : "netherrack" , properties : None , } , } ;
    pub const OVERWORLD : GenerationSettings = GenerationSettings { aquifers_enabled : true , ore_veins_enabled : true , legacy_random_source : false , sea_level : 63i32 , default_fluid : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } , shape : GenerationShapeConfig { min_y : - 64i8 , height : 384u16 , size_horizontal : 1u8 , size_vertical : 2u8 } , surface_rule : MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:bedrock_floor" , true_at_and_below : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 0i8 }) , false_at_and_above : YOffset :: AboveBottom (pumpkin_util :: y_offset :: AboveBottom { above_bottom : 5i8 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "bedrock" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: AbovePreliminarySurface (SurfaceMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 97i16 }) , surface_depth_multiplier : 2i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 62i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 60i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface_swamp" , min_threshold : 0f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: BADLANDS , & crate :: biome :: Biome :: ERODED_BADLANDS , & crate :: biome :: Biome :: WOODED_BADLANDS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 256i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.909f64 , max_threshold : - 0.5454f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.1818f64 , max_threshold : 0.1818f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.5454f64 , max_threshold : 0.909f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "terracotta" , properties : None , } }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "red_sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: Hole (HoleMaterialCondition) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 63i16 }) , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Not (NotMaterialCondition { invert : & MaterialCondition :: YAbove (AboveYMaterialCondition { anchor : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 74i16 }) , surface_depth_multiplier : 1i32 , add_stone_depth : true , }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "orange_terracotta" , properties : None , } }) }) }) , MaterialRule :: Badlands (BadLandsMaterialRule)] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "white_terracotta" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 1i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "air" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Temperature , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } })] }) }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : 0f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : 0f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.35f64 , max_threshold : 0.6f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.06060606060606061f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: OLD_GROWTH_PINE_TAIGA , & crate :: biome :: Biome :: OLD_GROWTH_SPRUCE_TAIGA] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "coarse_dirt" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.11515151515151514f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "podzol" , properties : Some (& [("snowy" , "false")]) , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: ICE_SPIKES] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MUSHROOM_FIELDS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mycelium" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "grass_block" , properties : Some (& [("snowy" , "false")]) , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] })] })] }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : - 6i32 , surface_depth_multiplier : - 1i32 , add_stone_depth : true , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_OCEAN , & crate :: biome :: Biome :: DEEP_FROZEN_OCEAN] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Hole (HoleMaterialCondition) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "water" , properties : Some (& [("level" , "0")]) , } }) }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:packed_ice" , min_threshold : - 0.5f64 , max_threshold : 0.2f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "packed_ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:ice" , min_threshold : - 0.0625f64 , max_threshold : 0.025f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "ice" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: SNOWY_SLOPES] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Steep , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "snow_block" , properties : None , } }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: GROVE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:powder_snow" , min_threshold : 0.45f64 , max_threshold : 0.58f64 , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Water (WaterMaterialCondition { offset : 0i32 , surface_depth_multiplier : 0i32 , add_stone_depth : false , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "powder_snow" , properties : None , } }) }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_PEAKS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:calcite" , min_threshold : - 0.0125f64 , max_threshold : 0.0125f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "calcite" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: STONY_SHORE] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:gravel" , min_threshold : - 0.05f64 , max_threshold : 0.05f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_HILLS] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DRIPSTONE_CAVES] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) })] }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_SAVANNA] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.21212121212121213f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WINDSWEPT_GRAVELLY_HILLS] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.24242424242424243f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: NoiseThreshold (NoiseThresholdMaterialCondition { noise : "minecraft:surface" , min_threshold : - 0.12121212121212122f64 , max_threshold : 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f64 , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: MANGROVE_SWAMP] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "mud" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "dirt" , properties : None , } })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: BEACH , & crate :: biome :: Biome :: SNOWY_BEACH] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 6i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: DESERT] , }) , then_run : & MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : true , secondary_depth_range : 30i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Floor , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: FROZEN_PEAKS , & crate :: biome :: Biome :: JAGGED_PEAKS] , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: Biome (BiomeMaterialCondition { biome_is : & [& crate :: biome :: Biome :: WARM_OCEAN , & crate :: biome :: Biome :: LUKEWARM_OCEAN , & crate :: biome :: Biome :: DEEP_LUKEWARM_OCEAN] , }) , then_run : & MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sandstone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "sand" , properties : None , } })] }) }) , MaterialRule :: Sequence (SequenceMaterialRule { sequence : & [MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: StoneDepth (StoneDepthMaterialCondition { offset : 0i32 , add_surface_depth : false , secondary_depth_range : 0i32 , surface_type : pumpkin_util :: math :: vertical_surface_type :: VerticalSurfaceType :: Ceiling , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "stone" , properties : None , } }) }) , MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "gravel" , properties : None , } })] })] }) })] }) }) , MaterialRule :: Condition (ConditionMaterialRule { if_true : MaterialCondition :: VerticalGradient (VerticalGradientMaterialCondition { random_name : "minecraft:deepslate" , true_at_and_below : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 0i16 }) , false_at_and_above : YOffset :: Absolute (pumpkin_util :: y_offset :: Absolute { absolute : 8i16 }) , }) , then_run : & MaterialRule :: Block (BlockMaterialRule { result_state : BlockBlueprint { name : "deepslate" , properties : Some (& [("axis" , "y")]) , } }) })] }) , default_block : BlockBlueprint { name : "stone" , properties : None , } , } ;
    pub fn from_dimension(dimension: &Dimension) -> &'static Self {
        if dimension == &Dimension::OVERWORLD {
            &Self::OVERWORLD
        } else if dimension == &Dimension::THE_NETHER {
            &Self::NETHER
        } else {
            &Self::END
        }
    }
}
